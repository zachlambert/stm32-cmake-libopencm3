import os
import json
import sys

template_nvic_h = '''\
/* This file is part of the libopencm3 project.
 */

#ifndef {includeguard}
#define {includeguard}

#include <libopencm3/cm3/nvic.h>

/** @defgroup CM3_nvic_defines_irqs User interrupts for {partname_humanreadable}
    @ingroup CM3_nvic_defines

    @{{*/

{irqdefinitions}

#define NVIC_IRQ_COUNT {irqcount}

/**@}}*/

/** @defgroup CM3_nvic_isrprototypes_{partname_doxygen} User interrupt service routines (ISR) prototypes for {partname_humanreadable}
    @ingroup CM3_nvic_isrprototypes

    @{{*/

BEGIN_DECLS

{isrprototypes}

END_DECLS

/**@}}*/

#endif /* {includeguard} */
'''

template_vector_nvic_c = '''\
/* This file is part of the libopencm3 project.
 *
 * It was generated by the irq2nvic_h script.
 *
 * This part needs to get included in the compilation unit where
 * blocking_handler gets defined due to the way #pragma works.
 */


/** @defgroup CM3_nvic_isrdecls_{partname_doxygen} User interrupt service routines (ISR) defaults for {partname_humanreadable}
    @ingroup CM3_nvic_isrdecls

    @{{*/

{isrdecls}

/**@}}*/

/* Initialization template for the interrupt vector table. This definition is
 * used by the startup code generator (vector.c) to set the initial values for
 * the interrupt handling routines to the chip family specific _isr weak
 * symbols. */

#define IRQ_HANDLERS \\
    {vectortableinitialization}
'''

template_irqhandlers_h = '''\
/* This file is part of the libopencm3 project.
 *
 * It was generated by the irq2nvic_h script.
 *
 * These definitions bend every interrupt handler that is defined CMSIS style
 * to the weak symbol exported by libopencm3.
 */

{cmsisbends}
'''

def main():
    if len(sys.argv) != 5:
        raise RuntimeError("Invalid usage")

    irq_path = sys.argv[1]
    out_nvic_h_path = sys.argv[2]
    out_vector_nvic_c_path = sys.argv[3]
    out_irqhandlers_h_path = sys.argv[4]

    os.makedirs(os.path.dirname(out_nvic_h_path), exist_ok=True)
    os.makedirs(os.path.dirname(out_vector_nvic_c_path), exist_ok=True)
    os.makedirs(os.path.dirname(out_irqhandlers_h_path), exist_ok=True)

    irq = json.load(open(irq_path))
    irq2name = list(enumerate(irq['irqs']) if isinstance(irq['irqs'], list) else irq['irqs'].items())
    irqnames = [v for (_,v) in irq2name]

    if isinstance(irq['irqs'], list):
        irq['irqcount'] = len(irq2name)
    else:
        irq['irqcount'] = max([int(x) for x in irq['irqs'].keys()]) + 1

    irq['irqdefinitions'] = "\n".join('#define NVIC_%s_IRQ %d'%(v.upper(),int(k)) for (k,v) in irq2name)
    irq['isrprototypes'] = "\n".join('void %s_isr(void);'%name.lower() for name in irqnames)
    irq['isrdecls'] = "\n".join('void %s_isr(void) __attribute__((weak, alias("blocking_handler")));'%name.lower() for name in irqnames)
    irq['vectortableinitialization'] = ', \\\n    '.join('[NVIC_%s_IRQ] = %s_isr'%(name.upper(), name.lower()) for name in irqnames)
    irq['cmsisbends'] = "\n".join("#define %s_IRQHandler %s_isr"%(name.upper(), name.lower()) for name in irqnames)


    open(out_nvic_h_path, 'w').write(template_nvic_h.format(**irq))
    open(out_vector_nvic_c_path, 'w').write(template_vector_nvic_c.format(**irq))
    open(out_irqhandlers_h_path, 'w').write(template_irqhandlers_h.format(**irq))



if __name__ == "__main__":
    main()
